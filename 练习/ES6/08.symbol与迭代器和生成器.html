<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //Symbol

        var a = Symbol('do you like me')     //symbol参数类似于注释，方便解读和区分
        console.log(a);
        console.log(typeof a);
        console.log(a.description);     //description会保存symbol对象的参数

        //Symbol声明的变量a就是一个独一无二的值

        toString(a)
        console.log(a);
        console.log(typeof a);//Symbol也可以转换字符串类型，但不能和其他数据类型进行计算

        //由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符
        //用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。

        let symbol = Symbol()
        let b = {}
        b[symbol] = 'hello'
        console.log(b);
        //注意，Symbol 值作为对象属性名时，不能用点运算符。因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。
       
       
        
       
        //迭代器
        var nameArr = ['qiaoyang','yagami','chihaya']
        
        for (var value of nameArr){        //var ... of ...遍历目标的内容，而for in 遍历返回的是下标
            console.log(value);
        }





        //生成器
        function * fn1(){
            yield;            //yield可以理解为return，但再次使用next调用时会继续执行后续代码并不会重新执行
            yield;       //另外需要注意，yield表达式只能用在 generator 函数里面，用在其他地方都会报错。
            yield 
        }
        let generator = fn1()
        console.log(generator);
        console.log(fn1());
        
        console.log(generator.next('a'));          //next返回两个值，第一个会返回yield返回的值，第二个参数会当yield没有返回值时返回True
        console.log(generator.next('b'));       //next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。
        
        console.log(generator.next(true));
        
        console.log(generator.next(true));
        


        /*setTimeout(function(){
            console.log('111');
            setTimeout(function(){
                console.log('222');
                setTimeout(function(){
                    console.log('333');          //这种反复回调的现象叫做回调地狱,让代码可读性降低并且难以维护
                    
                },3000)
            },2000)
        },1000)*/
        //通过生成器便能很好的解决这个问题

        function one (){
            setTimeout(function(){
                console.log('111');
                iterator2.next()
            },1000)
        }
        function two (){
            setTimeout(function(){
                console.log('222');
                iterator2.next()
            },2000)
        }
        function three (){
            setTimeout(function(){
                console.log('333');
            },3000)
        }
        function * time (){
            yield one()
            yield two()
            yield three()
        }
        let iterator2 = time()
        iterator2.next()
        
        
    </script>
</body>
</html>